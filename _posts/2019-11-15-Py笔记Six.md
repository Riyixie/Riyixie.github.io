---
layout: mypost
title: Py笔记SIx
categories: [Python]
---

## 函数简介（function）

函数也是一个对象,
对象是内存中专门用来存储数据的一块区域,
函数可以用来保存一些可执行的代码，并且可以在需要时，对这些语句进行多次的调用.

创建函数：

```py
    def 函数名([形参1,形参2,...形参n]) :
        代码块
```

> 函数名必需要符合标识符的规范（可以包含字母、数字、下划线、但是不能以数字开头）

函数中保存的代码不会立即执行，需要调用函数代码才会执行

调用函数：

- 函数对象()

定义函数一般都是要实现某种功能的。定义函数时指定形参，调用函数传递实参。

---

## 函数的参数

在定义函数时，可以在函数名后的()中定义数量不等的形参，
多个形参之间使用`,`隔开.

**形参（形式参数）**，定义形参就相当于在函数内部声明了变量，但是并不赋值,
定义形参时，可以为形参指定默认值,
指定了默认值以后，如果用户传递了参数则默认值没有任何作用,
如果用户没有传递，则默认值就会生效..

**实参（实际参数）**,
如果函数定义时，指定了形参，那么在调用函数时也必须传递实参，
实参将会赋值给对应的形参，简单来说，有几个形参就得传几个实参..

<span style="color:#0ff; font-weight:bold;">实参的传递方式</span>

---

- **位置参数**

  位置参数就是将对应位置的实参赋值给对应位置的形参，
  第一个实参赋值给第一个形参，第二个实参赋值给第二个形参 。。。

- **关键字参数**

  关键字参数，可以不按照形参定义的顺序去传递，而直接根据参数名去传递参数

> 位置参数和关键字参数可以混合使用，混合使用关键字和位置参数时，必须将位置参数写到前面。

函数在调用时，解析器不会检查实参的类型，
实参可以传递任意类型的对象，
在定义函数时，可以在形参前边加上一个`*`，这样这个形参将会获取到所有的实参，
它将会将所有的实参保存到一个元组中,
星号的形参只能有一个,
带星号的参数，可以和其他参数配合使用..

可变参数不是必须写在最后，但是注意，带`*`的参数后的所有参数，必须以关键字参数的形式传递,
所有的位置参数都给 a，b 和 c 必须使用关键字参数,
如果在形参的开头直接写一个`*`,则要求我们的所有的参数必须以关键字参数的形式传递,
`*`形参只能接收位置参数，而不能接收关键字参数.
\*\*形参可以接收其他的关键字参数，它会将这些参数统一保存到一个字典中,
字典的 key 就是参数的名字，字典的 value 就是参数的值,
\*\*形参只能有一个，并且必须写在所有参数的最后..

---

- **参数的解包（拆包）**

  传递实参时，也可以在序列类型的参数前添加星号，这样他会自动将序列中的元素依次作为参数传递,
  这里要求序列中元素的个数必须和形参的个数的一致,
  通过 \*\*来对一个字典进行解包操作..

- **返回值**

  返回值就是函数执行以后返回的结果,
  可以通过 `return` 来指定函数的返回值,
  可以直接使用函数的返回值，也可以通过一个变量来接收函数的返回值。
  `return` 后边跟什么值，函数就会返回什么值,
  `return` 后边可以跟任意的对象，返回值甚至可以是一个函数,
  如果仅仅写一个`return` 或者 不写`return`，则相当于`return None`,
  在函数中，`return`后的代码都不会执行，`return` 一旦执行函数自动结束..

- **help()**

  help()是 Python 中的内置函数,
  通过 help()函数可以查询 python 中的函数的用法;

语法：`help(函数对象)`.

```py
help(print) # 获取print()函数的使用说明
```

- **文档字符串（doc str）**

  在定义函数时，可以在函数内部编写文档字符串，文档字符串就是函数的说明,
  当我们编写了文档字符串时，就可以通过 help()函数来查看函数的说明,
  文档字符串非常简单，其实直接在函数的第一行写一个字符串就是文档字符串..

例：

```py
def fn(a:int,b:bool,c:str='hello') -> int:
    '''
    这是一个文档字符串的示例

    函数的作用：。。。。。
    函数的参数：
        a，作用，类型，默认值。。。。
        b，作用，类型，默认值。。。。
        c，作用，类型，默认值。。。。
    '''
    return 10

help(fn)
```

---

<div style="color:#0ff; font-weight:blod;"> 作用域（scope）</div>

作用域指的是变量生效的区域,
定义在函数内部，所以他的作用域就是函数内部，函数外部无法访问,
在 Python 中一共有两种作用域:

- **全局作用域**

  全局作用域在程序执行时创建，在程序执行结束时销毁,
  所有函数以外的区域都是全局作用域,
  在全局作用域中定义的变量，都属于全局变量，全局变量可以在程序的任意位置被访问.

- **函数作用域**

  函数作用域在函数调用时创建，在调用结束时销毁,
  函数每调用一次就会产生一个新的函数作用域,
  在函数作用域中定义的变量，都是局部变量，它只能在函数内部被访问.

---

- **变量的查找**

  当我们使用变量时，会优先在当前作用域中寻找该变量，如果有则使用
  如果没有则继续去上一级作用域中寻找，如果有则使用，
  如果依然没有则继续去上一级作用域中寻找，以此类推...
  直到找到全局作用域，依然没有找到，则会抛出异常`NameError: name 'x' is not defined`

在函数中为变量赋值时，默认都是为局部变量赋值,
如果希望在函数内部修改全局变量，则需要使用 global 关键字，来声明变量.
`global a`声明在函数内部的使用 a 是全局变量，此时再去修改 a 时，就是在修改全局的 a.
`globals()` 函数可以用来在任意位置获取全局命名空间...

- **命名空间（namespace）**

  命名空间指的是变量存储的位置，每一个变量都需要存储到指定的命名空间当中，
  每一个作用域都会有一个它对应的命名空间,
  全局命名空间，用来保存全局变量。函数命名空间用来保存函数中的变量,
  命名空间实际上就是一个字典，是一个专门用来存储变量的字典.

**locals()** 用来获取当前作用域的命名空间,
如果在全局作用域中调用`locals()`则获取全局命名空间，
如果在函数作用域中调用`locals()`则获取函数命名空间，
返回的是一个字典。

在函数内部调用`locals()`会获取到函数的命名空间,
可以通过`scope`来操作函数的命名空间，但是也是不建议这么做...

- **递归式的函数**

  归简单理解就是自己去引用自己！递归式函数，在函数中自己调用自己！
  无穷递归，如果这个函数被调用，程序的内存会溢出，效果类似于死循环......

递归是解决问题的一种方式，它和循环很像,
它的整体思想是，将一个大问题分解为一个个的小问题，直到问题无法分解时，再去解决问题.

递归式函数的两个要件:

1. 基线条件
   - 问题可以被分解为的最小问题，当满足基线条件时，递归就不在执行了
2. 递归条件
   - 将问题继续分解的条件

递归和循环类似，基本是可以互相代替的，
循环编写起来比较容易，阅读起来稍难,
递归编写起来难，但是方便阅读...

---

<div style="color:#0bf; font-weight:bold;">递归练习</div>

**One**&emsp;&emsp;创建一个函数 power 来为任意数字做幂运算`n ** i`.

```py
def power(n , i):
    '''
        power()用来为任意的数字做幂运算

        参数：
            n 要做幂运算的数字
            i 做幂运算的次数
    '''
    # 基线条件
    if i == 1:
        # 求1次幂
        return n
    # 递归条件
    return n * power(n , i-1)
```

**Two**&emsp;&emsp;创建一个函数，用来检查一个任意的字符串是否是回文字符串字符串从前往后念和从后往前念是一样的)，如果是返回 True，否则返回 False.

```py
def hui_wen(s):
    '''
        该函数用来检查指定的字符串是否回文字符串，如果是返回True，否则返回False

        参数：
            s：就是要检查的字符串
    '''
    # 基线条件
    if len(s) < 2 :
        # 字符串的长度小于2，则字符串一定是回文
        return True
    elif s[0] != s[-1]:
        # 第一个字符和最后一个字符不相等，不是回文字符串
        return False
    # 递归条件
    return hui_wen(s[1:-1])
```

<center>OR</center>

```py
def hui_wen(s):
    '''
        该函数用来检查指定的字符串是否回文字符串，如果是返回True，否则返回False

        参数：
            s：就是要检查的字符串
    '''
    # 基线条件
    if len(s) < 2 :
        # 字符串的长度小于2，则字符串一定是回文
        return True
    # 递归条件
    return s[0] == s[-1] and hui_wen(s[1:-1])
```

## 函数式编程

在 Python 中，函数是一等对象,
一等对象一般都会具有如下特点：

    ①. 对象是在运行时创建的
    ② 能赋值给变量或作为数据结构中的元素
    ③ 能作为参数传递
    ④ 能作为返回值返回

- **高阶函数**

  接收函数作为参数，或者将函数作为返回值的函数是高阶函数,
  当我们使用一个函数作为参数时，实际上是将指定的代码传递进了目标函数

高阶函数至少要符合以下两个特点中的一个

    ① 接收一个或多个函数作为参数
    ② 将函数作为返回值返回

- **filter()**

  filter()可以从序列中过滤出符合条件的元素，保存到一个新的序列中.

参数：

1. 函数，根据该函数来过滤序列（可迭代的结构）
2. 需要过滤的序列（可迭代的结构）

返回值：
过滤后的新序列（可迭代的结构）

- **匿名函数 lambda 函数表达式 （语法糖）**

  lambda 函数表达式专门用来创建一些简单的函数，他是函数创建的又一种方式,
  语法：`lambda 参数列表 : 返回值`,
  匿名函数一般都是作为参数使用，其他地方一般不会使用,
  也可以将匿名函数赋值给一个变量，一般不会这么做.

- **map()**

  map()函数可以对可迭代对象中的所有元素做指定的操作，然后将其添加到一个新的对象中返回

- **sort()**

  该方法用来对列表中的元素进行排序，
  `sort()`方法默认是直接比较列表中的元素的大小,
  在 sort()可以接收一个关键字参数`key`,
  key 需要一个函数作为参数，当设置了函数作为参数,
  每次都会以列表中的一个元素作为参数来调用函数，并且使用函数的返回值来比较元素的大小,
  会影响原来的对象...

- **sorted()**

  这个函数和 sort()的用法基本一致，但是 sorted()可以对任意的序列进行排序,
  并且使用 sorted()排序不会影响原来的对象，而是返回一个新对象.

将函数作为返回值返回，也是一种高阶函数，
这种高阶函数我们也称为叫做闭包，通过闭包可以创建一些只有当前函数能访问的变量，
可以将一些私有的数据藏到的闭包中。

形成闭包的要件：

    ① 函数嵌套
    ② 将内部函数作为返回值返回
    ③ 内部函数必须要使用到外部函数的变量

---

## 装饰器

创建一个函数，让这个函数可以自动的帮助我们生产函数，
希望在不修改原函数的情况下，来对函数进行扩展。
这种函数我们就称它为**装饰器**，通过装饰器，可以在不修改原来函数的情况下来对函数进行扩展。

在开发中，我们都是通过装饰器来扩展函数的功能的，
在定义函数时，可以通过`@装饰器`，来使用指定的装饰器，来装饰当前的函数，
可以同时为一个函数指定多个装饰器，这样函数将会安装从内向外的顺序被装饰。
