---
layout: mypost
title: 面试题个人理解
categories: [new,闭包,状态码]
---



### 闭包

1. 什么是闭包？

   > 在我的理解中，闭包由一个函数和可访问的变量共同构成，从广义的角度来讲，js代码中一切的函数和变量构成一个闭包，从狭义的角度来讲，闭包的构成必须由一个函数和一个**可访问**的且**已访问**的变量构成；

2. 闭包

   > 闭包的存在有利于变量的私有化，不可使变量随意被修改，但使用过多会造成内存泄漏；内存泄漏指的是本该在函数执行上下文栈出时，此函数内部的变量应被销毁，以释放占用的空间，但因闭包的存在导致该变量并未被GC垃圾回收；这样该变量便在全局执行上下文未栈出时一直存在；
   >
   > 如果我们必须将一个变量私有，那么我们在使用闭包后为了解决该变量未被GC垃圾回收的问题，
   >
   > 一般会将该变量名指向`null`，即`variable=null`;
   >
   > 这样的操作依据是利用了GC的机制，GC存在两大机制，
   >
   > ①引用清除法：
   >
   > ​	如果一个值被一个变量名所指，那便不会被销毁；这个机制的漏洞是容易出现循环指向，即A对象内部有变量指向B对象，且B对象内部也有变量指向A对象，此时处于相互引用，所以GC并不会销毁该值；
   >
   > ②标记清除法：
   >
   > ​	在GC初始执行时，首先于`VO`或`VE`中依次向下层进行标记，在后续执行时，将没有被进行标记的清除；V8引擎目前使用的时标记清除法+其他优化操作；

### new的过程

当执行new时，存在以下操作过程

1. 首先在堆空间中创建一个对象，
2. 构造函数将自身的`prototype`赋值给这个对象的`__proto`
3. 将这个对象的this指向变量
4. 执行构造函数中剩余的代码，如果没有其它return，那将这个对象return出去

### 箭头函数有哪些特点

①箭头函数自身不会创建this，它的this依托于上层作用域的this

②箭头函数无法作为构造函数使用，因为它没有`prototype`，使用new的前提使该函数有`prototype`

③箭头函数没有自己的`arguments`伪数组，所以更推荐使用`...args`剩余参数写法

④箭头函数不支持重命名函数参数

### HTTP状态码

| 状态信息 |                     实际信息                     |
| :------: | :----------------------------------------------: |
|   1**    |           已发送请求，但客户端尚未响应           |
|   2**    |               客户端响应，请求成功               |
|   3**    |          资源重定向，需客户端进一步操作          |
|   304    |       服务器鉴别本地缓存，无误后从本地获取       |
|   4**    | 客户端请求错误，包含语法错误或无法完成相应的请求 |
|   5**    |           服务器错误，处理请求发生错误           |

### Promise

Promise在pending状态会调用`.then`,但是并不会进去内里的回调函数

Promise.rece虽然会返回第一个值，但是并不会直接结束剩余Promise，会将所有的Promise都执行完

async执行后仅return，那返回的是一个Promise，并且状态为成功

### Event Loop

setTimeout(()=>{},0);此时的0并不为0，实际setTimout的最小时间为4ms调用一次回调函数

微任务:Promise.then()、.catch()、.finally()

宏任务:setTimeout、setInterval、异步Ajax请求、

先同步，后异步，异步如果挂在同步上，则先执行同步的微任务，后执行