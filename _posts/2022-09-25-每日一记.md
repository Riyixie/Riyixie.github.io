---
layout: mypost
title: 每日一记
categories: [手写,面试]
---

### try&catch&finally

正常情况下，函数在try中执行可能出现错误的代码块，使用catch来捕获try中可能出现的错误

```js
function foo(){
    try{
        console.log('try')
        throw new Error()
    }catch(err){
        console.log(err)
    }
}
foo(); 
//此时当try执行时先输出try，后抛出错误，此时错误被catch捕获，执行catch中的代码块
```

常规情况下当catch捕获到try中的错误后，并不会阻断后续代码的执行

```js
function foo(){
    try {
        console.log('try')
        throw new Error()
    }catch(err){
        console.log(err)
    }
    console.log('还会执行的')   //此时即便出现错误也会执行，前面出现不影响
}
```

第一种 try中在抛出错误前return，则catch并不会捕获错误，并不执行catch的代码块，但此时会直接阻断后续所有代码的执行

```js
function foo(){
    try {
        console.log('try')
        return 
        throw new Error()
    }catch(err){
        console.log(err)
    }
    console.log('不会执行了')   //try直接return，直接阻断所有代码执行
}
```

第二种 try中在抛出错误后return,则catch会捕获错误并继续执行catch的代码块，阻断catch之后的代码执行

```js
function foo(){
    try {
        console.log('try')
        throw new Error()
        return 
    }catch(err){
        console.log('err') //抛出错误后依旧被执行
    }
   	console.log('不会被执行了')
}
```

第三种 try不论在抛出错误前return还是抛出错误后return，此时都会执行finally中的代码

```js
function foo(){
    try {
        return 
        console.log('try')
        return
    }catch(err){
        console.log(err)  //不执行了，被try return了
    }finally{
        console.log('必须被执行')
    }
    console.log('并不会被执行')
}
```

第四种 当catch捕获到错误后直接return，则依旧会执行finally

```js
function foo(){
   try {
       console.log(try)
       throw new Error()
   } catch(err){
       return   //此时err不会被输出 
       console.log(err)
       return  //输出err之后阻断
   }finally{
       console.log('并不影响我输出')
   }
    console.log('我还是不会被执行')
}
```

第五种 当finally中出现return时，如果在最前面，则直接阻断剩余代码块的执行，如果在finally的作用域最后，则会在执行完finally中之后阻断剩余代码块的执行

```js
function foo(){
    try {
        console.log('try')
        throw new Error()
    }catch(err){
        console.log(err)
    }finally{
        return //阻断后续代码执行
        console.log('可能被执行')
        return //阻断后续代码执行
    }
    consoel.log('我一定不会被执行')
}
```



### 手写axios

```js
Promise.prototype.hyAxios = options =>{  //axios执行后会返回的时promise，所以我们在开始时直接设定返回一个promise
    return new Promise((resolve,reject)=>{
        const xhr = new XMTLHttpRequest()
        
        if(option.method.toLowerCase === 'get'){
            option.url = params
            ? (option.url += '?' + localStr(option.params))
            : option.url
			xhr.open('get', option.url)
			xhr.send()  //第一种写法
            
			xhr.open(
				'get',
				option.url + (option ? '?' + localStr(option.params) : '')
			)
			xhr.send()  //第二种写法
        }else if(option.method.toLowerCase === 'post'){
            xhr.XMLRequestHeader('Content-Type','application/json')
            xhr.open('post',option.url)
            xhr.send(JSON.stringify(option.data))
        }
        
        xhr.open(options.method,options.url)  //接受两个参数
        
        xhr.send()
        
        xhr.onreadystatuechange = ()=>{
            if(xhr.readyStatue === 4){//发送完成时
                xhr.status >= 200 && xhr.status <300
                ?resolve(JSON.parse(xhr.responeText))  //成功时使promise为成功
                :reject(JSON.parse(xhr.responseText))  //失败时使promise为失败
            }  
        }
    })
}

const localStr = obj =>{
    var  arr = []
    for(let i = 0; i <obj.length;i++){
        arr.push(key+'='+obj[key])
    }
    return arr.join('&')
}
```

### JSON实现深拷贝

`JSON`无法识别undefined，function

```js
const a = {
    b : 'james',
    c : 123,
    c : null,
    e : {name : 'xi'},
    f : [1,2,3,4],
    g : function (){
        return 'heiheihei'
    },
    h : undefined
}
const b = JSON.parse(JSON.Stringify(a))
```

### new时发生了什么

1. 首先在堆内存中开辟新空间，创建该对象
2. 将构造函数的prototype赋值给实例对象的[[prototype]]
3. 随后将this指向这个新的实例对象
4. 执行构造函数中的代码，给实例对象加属性
5. 如果构造函数返回对象，则返回该对象；否则返回新创建的空对象

```js
function Star (name,age){
    this.name = name
    this.age = age
    return [1,2,3]  //如果有return，则返回该值
}
const aa = new Star('xi',20)
// 1.创建新对象
const obj = {}
//2.将构造函数的prototype赋值给实例对象的__proto__
obj.__proto__ = Star.prototype
//3.将this指向新对象，并给实例对象加属性
Star.call(obj,'xi',20)
//4.返回这个新对象
console.log(obj)
```

### 手写new

```js
Object.prototype.hyNew = funciton(fn,...args){
    const obj = {}
    obj.__proto__ = fn.prototype
   	fn.apply(this,args)
    return obj
}
```

`Promise.all`类似于`与`，只要有一个，则全部失败，如果成功，则返回一个新数组

`Promise.race`接收数组，第一个完成，则接收它的结果，如果第一个完成的为失败，则全部失败；当第一个为第一个完成的，则后续代码的promise会执行吗？会的，只不过不使用他们的值

#### push有没有返回值呢，有的，返回的时push后数组的长度

